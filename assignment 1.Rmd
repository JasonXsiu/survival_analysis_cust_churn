```{r}
library(tidyverse)
library(readr)
library(survminer)
library(survival)
library(broom)
library(ggfortify)
library(tidyr)
## Remove the line break in the file name! churn_dat <-
churn_dat <-read_csv("https://raw.githubusercontent.com/square/pysurvival/master/pysurvival/datasets/churn.csv")
churn_dat <- churn_dat %>% filter(months_active > 0)
set.seed(12345)
```


• Write a function that takes a survival pair (time, event) and uses it to compute the Kaplan-Meier estimate of the survival function. It should work for any survival data. 

```{r}
view(churn_dat)
```


```{r Q1-function}
#t = at a particular time period
#n = # of the individuals that are still surviving at t (i.e customer still using our services)
#d = # of event at t (i.e customer left)

KM_estimate <- function (time, event) 
{
    sorted_time <- sort(time)
    event <- event[order(time)] # event being ordered
    ni <- length(time):1
    ni <- ni[!duplicated(sorted_time)]
    di <- tapply(event, sorted_time, sum)
    ti <- unique(sorted_time)
    si <- (ni - di)/ni
    cum_survivial_i <- cumprod(si)
    cum_risk_i <- 1 - cum_survivial_i
    results <- cbind(time = ti, n_risk = ni, n_events = di, condsurv = si, 
        survival = cum_survivial_i, risk = cum_risk_i)
    dimnames(results)[1] <- list(NULL)
    results[, ]
}

```


```{r Q1-Plot-full_data}
time <-  churn_dat$months_active 
event <- churn_dat$churned
result <- KM_estimate(time, event)
result <- as.data.frame(result)
```



```{r}
ggplot(result, aes(x=time, y = survival))+geom_point()+geom_step ()+theme_bw()
```



====================== Q1 B


```{r}
df_10to50 <-  churn_dat %>% filter(company_size == "10-50")

s1_time <-  df_10to50$months_active 
s1_event <- df_10to50$churned
s1_result <- KM_estimate(s1_time, s1_event)
s1_result <- as.data.frame(s1_result)


#100-250
df_100to250 <- churn_dat %>% filter(company_size ==  "100-250")

s2_time <-  df_100to250$months_active 
s2_event <- df_100to250$churned
s2_result <- KM_estimate(s2_time, s2_event)
s2_result <- as.data.frame(s2_result)



#"50-100" 
df_50to100 <- churn_dat %>% filter(company_size ==  "50-100")

s3_time <-  df_50to100$months_active 
s3_event <- df_50to100$churned
s3_result <- KM_estimate(s3_time, s3_event)
s3_result <- as.data.frame(s3_result)



#"1-10"
df_1to10 <- churn_dat %>% filter(company_size ==  "1-10")

s4_time <-  df_1to10$months_active 
s4_event <- df_1to10$churned
s4_result <- KM_estimate(s4_time, s4_event)
s4_result <- as.data.frame(s4_result)


# "self-employed"

df_self_employed <- churn_dat %>% filter(company_size ==  "self-employed")
s5_time <-  df_self_employed$months_active 
s5_event <- df_self_employed$churned
s5_result <- KM_estimate(s5_time, s5_event)
s5_result <- as.data.frame(s5_result)

```

```{r plot-by-sizes}

colors <- c("s1"="red", "s2" = "blue","s3" = "green","s4" = "pink","s5" = "black")

ggplot()+
    geom_step(data =s1_result,  
              aes(x=time, y = survival,
              color = "s1"),
              size = 1.5)+
    geom_step(data =s2_result,  
              aes(x=time, y = survival,
              color = "s2"),
              size = 1.5)+
    geom_step(data =s3_result,  
              aes(x=time, y = survival,
              color = "s3"),
              size = 1.5)+
    geom_step(data =s4_result,  
              aes(x=time, y = survival,
              color = "s4"),
              size = 1.5)+
    geom_step(data =s5_result,  
              aes(x=time, y = survival,
              color = "s5"),
              size = 1.5,
              linetype = 2)+
    labs(x= 'Time',
         y="Prob.Survival",
         color = 'Legend')+
        scale_color_manual(values = colors)+
    theme_bw()+
    theme(legend.position = c(.1,.26))
```




====================== Q2 A

```{r function-to-find-median}


near_median <- function(fit){
if (length(fit$n) > 1) {
stop("This only works for a single survival curve!")
}
index <- which.min(abs(fit$surv - 0.5))
return(fit$time[index])
}

average_median <- function(fit) {
if (length(fit$n) > 1) {
stop("This only works for a single survival curve!")
}
suppressWarnings(lower_ind <- which.min(log(fit$surv - 0.5)))
suppressWarnings(upper_ind <- which.min(log(0.5 - fit$surv)))
return((fit$time[lower_ind] + fit$time[upper_ind])/2)
}


```
```{r Q2-10to50}

#10-50
df_10to50 <-  churn_dat %>% filter(company_size == "10-50")
time <-  df_10to50$months_active 
event <- df_10to50$churned

fit <- surv_fit(Surv(time,event)~1, data = df_10to50) 
#calculate the avg median
s1_median <- near_median(fit)
s1_median

#find out if we use avg median or near median
fit <-  fit%>% tidy()#tidy the "fit"
df <- fortify(round(fit,3))
df[s1_median,]
```
'The median time is where the survival probability is equal to 0.5. Although there is no exact time where this occurs we know that the median exists between times 5 and 6. As the survival probabilities of the two times are near equally far from 0.5 (which are  0.505 and  0.493 respectively), we can use the average median of 5.5 as the most suitable measure of the median.'

```{r median-estimation-function}

estimate_median <- function(size){
df <- churn_dat %>% filter(company_size == size)
time <-  df$months_active 
event <- df$churned
fit <- surv_fit(Surv(time,event)~1, data = df) 

#find the index of the near median
index <- near_median(fit)

#return the median of churn time
fit <-  fit%>% tidy()#tidy the "fit"
df <- fortify(round(fit,3))
return(df[index,])
}

```

```{r estimate-median}
#here estimate median based on sizes
estimate_median("10-50")
estimate_median("100-250")
estimate_median("50-100")
estimate_median("1-10")
estimate_median("self-employed")
```




====================== Q2 B

Use a non-parametric bootstrap to construct 90% conﬁdence intervals for the median of each company size


#this is the wrong version previously made
```{r 10-50}
set.seed(12345)


y <- df_10to50 %>% select(time) %>% average_median()
n_sample <-  nrow(df_10to50)

bootstrap <- tibble(experiment = rep(1:10000, each =n_sample),
                    ind = sample(1:n_sample, size = n_sample*10000, 
                                 replace = TRUE) ,
                    ystar = y[ind,] # R you sure it is   y[ind,]  or  y[ind] 
                    )%>% unpack(ystar)


y_bar<- mean(y$Avg_median)# mean of Avg_median
bias <- bootstrap %>%
    group_by(experiment) %>%
    summarise(delta = y_bar - mean(Avg_median))
boot_ci <-y_bar + quantile(bias$delta, c(0.05, 0.95)) #bootstrap interval at 90%




```


```{r bootstrap}
#create a function of  the dataframe by sizes
boot <- function(size,n_sims){
#1. filter data into a particular size
df <- churn_dat %>% filter(company_size == size)
n = nrow(df)
#2. run the bootstrap
experiments = tibble(experiment = rep(1:n_sims, each = n),
                     index = sample(1:n, size = n * n_sims, replace = TRUE),
                     time_star = df$months_active[index],
                     event_star = df$churned[index])
return(experiments)
}

```

```{r plotting-hist}

#create a function for plotting
plot_boot_data <- function(experiments){
  fit <- survfit(Surv(time_star, event_star) ~ experiment, data = experiments)
  #get the median of surv
  med <- surv_median(fit)
  med <- data.frame(med = med$median)
  ggplot(med , aes(x = med, fill= med)) +
    geom_histogram(binwidth = .8)+theme_bw()
}
```


```{r}
# for the sake of testing, the sample size is set to 10, instead of 1000
set.seed(9999)
#"10-50"
df_10to50 <- boot("10-50",10)
plot_boot_data(df_10to50)

#"100-250"
df_100to250 <- boot("100-250",10)
plot_boot_data(df_100to250)

#"50-100"
df_50to100 <- boot("50-100",10)
plot_boot_data(df_50to100)

#"1-10"              
df_1to10 <- boot("1-10",10)
plot_boot_data(df_1to10)


#"self-employed"
df_self_employed <- boot("self-employed",10)
plot_boot_data(df_self_employed)
```